/*
 * QEMU PowerPC PowerNV OpenCAPI memcpy AFU model
 *
 * Copyright (c) 2019-2020, IBM Corporation.
 *
 * This code is licensed under the GPL version 2 or later. See the
 * COPYING file in the top-level directory.
 */

#include "qemu/osdep.h"
#include "qemu/bswap.h"
#include "qemu/log.h"

#include "hw/ppc/ocapi_afu.h"

#define CONFIG_SPACE_SIZE    4096
#define INVALID_DATA         ~0ULL


typedef struct {
    int offset;
    char val[16];
} cfg_data_t;

cfg_data_t cfg0_data [] = {
    { 0x000, { 0x14, 0x10, 0x2b, 0x06, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x80, 0x00 } },
    { 0x010, { 0x04, 0x00, 0x00, 0x04, 0xe8, 0x00, 0x06, 0x00, 0x04, 0x00, 0x01, 0x04, 0xe8, 0x00, 0x06, 0x00 } },
    { 0x020, { 0x04, 0x00, 0x02, 0x04, 0xe8, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x10, 0x0f, 0x06 } },
    { 0x030, { 0x00, 0xf8, 0xff, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x040, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x050, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x100, { 0x03, 0x00, 0x01, 0x20, 0xad, 0xde, 0xad, 0xde, 0xad, 0xde, 0xad, 0xde, 0xff, 0xff, 0xff, 0xff } },
    { 0x110, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x200, { 0x23, 0x00, 0x01, 0x30, 0x14, 0x10, 0x00, 0x09, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03 } },
    { 0x210, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00 } },
    { 0x220, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x230, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x240, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x27, 0x00, 0x00 } },
    { 0x250, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x260, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00 } },
    { 0x270, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x290, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x300, { 0x23, 0x00, 0x01, 0x60, 0x14, 0x10, 0x00, 0x01, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x310, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x600, { 0x23, 0x00, 0x01, 0x00, 0x14, 0x10, 0x80, 0x03, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x16, 0x01, 0x18 } },
    { 0x610, { 0x00, 0x10, 0x10, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x620, { 0x00, 0x25, 0x10, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x630, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x640, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { -1 }
};

cfg_data_t cfg1_data [] = {
    { 0x000, { 0x14, 0x10, 0x2b, 0x06, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x80, 0x00 } },
    { 0x010, { 0x04, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x06, 0x00, 0x04, 0x00, 0x03, 0x04, 0xe8, 0x00, 0x06, 0x00 } },
    { 0x020, { 0x04, 0x00, 0x04, 0x04, 0xe8, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x10, 0x0f, 0x06 } },
    { 0x030, { 0x00, 0xf8, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x040, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x100, { 0x1b, 0x00, 0x01, 0x30, 0x00, 0x09, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x110, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x300, { 0x23, 0x00, 0x01, 0x40, 0x14, 0x10, 0x00, 0x01, 0x01, 0xf0, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 } },
    { 0x310, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x400, { 0x23, 0x00, 0x01, 0x50, 0x14, 0x10, 0x40, 0x01, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x410, { 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x420, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x500, { 0x23, 0x00, 0x01, 0x60, 0x14, 0x10, 0x00, 0x02, 0x04, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x510, { 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { 0x520, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { 0x600, { 0x23, 0x00, 0x01, 0x00, 0x14, 0x10, 0xc0, 0x00, 0xf0, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff } },
    { 0x610, { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
    { -1 }
};

char *config_spc[2];

//#define AFU_DEBUG
#ifdef AFU_DEBUG
#define DEBUG(fmt, ...) do {         \
        fprintf(stderr,  "%s: " fmt, __func__, ## __VA_ARGS__);  \
    } while (0);
#else
    #define DEBUG(...) do {} while (0)
#endif


static void memcpy_write_cfg(int func, int reg, uint64_t val, int size)
{
    printf("write_cfg for function %d, offset %x, val=%lx, size=%d\n",
           func, reg, val, size);
}

static void init_config_space(int fn)
{
    cfg_data_t *data;
    char *c;

    assert(fn == 0 || fn == 1);

    config_spc[fn] = g_malloc0(CONFIG_SPACE_SIZE);
    if (fn == 0)
        data = cfg0_data;
    else
        data = cfg1_data;

    while (data->offset != -1) {
        c = config_spc[fn] + data->offset;
        for (int i = 0; i < 16; i++)
            c[i] = data->val[i];
        data++;
    }
}

static uint64_t memcpy_read_cfg(int fn, int reg, int size)
{
    uint8_t *c;
    uint16_t *h;
    uint32_t *w;

    DEBUG("read_cfg for function %d, offset %x, size=%d\n",
           fn, reg, size);

    if ((reg + size) >= CONFIG_SPACE_SIZE) {
        qemu_log_mask(LOG_GUEST_ERROR, "Unexpected config read address 0x%x\n", reg);
        return INVALID_DATA;
    }
    if (fn != 0 && fn != 1)
        return INVALID_DATA;

    if (!config_spc[fn]) {
        init_config_space(fn);
    }

    switch (size) {
    case 1:
        c = (uint8_t *) (config_spc[fn] + reg);
        return *c;
    case 2:
        h = (uint16_t *) (config_spc[fn] + reg);
        return cpu_to_be16(*h);
    case 4:
        w = (uint32_t *) (config_spc[fn] + reg);
        return cpu_to_be32(*w);
    default:
        qemu_log_mask(LOG_GUEST_ERROR, "Unexpected config read size %d for offset 0x%x\n",
                      size, reg);
    }
    return INVALID_DATA;
}

ocapi_afu_t ocapi_afu_memcpy = {
    .write_cfg = memcpy_write_cfg,
    .read_cfg = memcpy_read_cfg
};
